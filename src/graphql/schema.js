const Promise = require("bluebird");
const { readFileSync } = require("fs");
const path = require("path");
const { makeExecutableSchema } = require("graphql-tools");
const title = require("uppercamelcase");
const merge = require("deepmerge");
const resolvers = require("./resolvers").default;
const { getPlayerStats } = require("./apiClient");

export const schemaFile = path.resolve("schema.graphql");

const baseSchema = `
# Auto-generated by bin/generate-schema
# DO NOT EDIT MANUALLY, ALL CHANGES WILL BE OVERWRITTEN

interface Node {
    id: ID!
}

type LeagueDivision implements Node {
    id: ID!
    name: String!
    abbrev: String!
}

type LeagueDivisionConnection {
    edges: [LeagueDivisionEdge]
    pageInfo: PageInfo!
}

type LeagueDivisionEdge {
    cursor: String!
    node: LeagueDivision
}

type LeagueTeam implements Node {
    id: ID!
    name: String!
    homeLocation: String!
    primaryColor: String!
    secondaryColor: String!
    abbreviatedName: String!
    logo: String!
    icon: String!
    secondaryPhoto: String!
    players(after: String, first: Int!): LeaguePlayerConnection @cost(complexity: 1, useMultipliers: true, multiplier: "first")
}

type LeagueTeamConnection {
    edges: [LeagueTeamEdge]
    pageInfo: PageInfo!
}

type LeagueTeamEdge {
    cursor: String!
    node: LeagueTeam
}

type LeaguePlayer implements Node {
    id: ID!
    name: String!
    homeLocation: String
    accounts(after: String, first: Int!): LeagueAccountConnection @cost(complexity: 1, useMultipliers: true, multiplier: "first")
    heroes: [String],
    playerNumber: Int!
    role: String!
    familyName: String!
    givenName: String!
    nationality: String!
    headshot: String!
}

type LeaguePlayerConnection {
    edges: [LeaguePlayerEdge]
    pageInfo: PageInfo!
}

type LeaguePlayerEdge {
    cursor: String!
    node: LeaguePlayer
}

type LeagueAccount implements Node {
    id: ID!
    playerId: ID!
    value: String!
    accountType: String!
    isPublic: Boolean!
}

type LeagueAccountConnection {
    edges: [LeagueAccountEdge]
    pageInfo: PageInfo!
}

type LeagueAccountEdge {
    cursor: String!
    node: LeagueAccount
}

type LeagueRank {
    advantage: Int!
    team: LeagueTeam!
    placement: Int!
    records: [LeagueRecord]
}

type LeagueRecord {
    gameLoss: Int!
    gamePointsAgainst: Int!
    gamePointsFor: Int!
    gameTie: Int!
    gameWin: Int!
    matchBye: Int!
    matchDraw: Int!
    matchLoss: Int!
    matchWin: Int!
}

type LeagueStage implements Node {
    id: ID!
    name: String!
    teams(after: String, first: Int!): LeagueTeamConnection
}

type LeagueStageConnection {
    edges: [LeagueStageEdge]
    pageInfo: PageInfo!
}

type LeagueStageEdge {
    cursor: String!
    node: LeagueStage
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
}

type Achievement {
  name: String!
  achieved: Boolean!
}

type PlayerAccountStats {
  competitiveRank: Int
  achievements: [Achievement!]!
  quickplay: GamemodeStats!
  competitive: GamemodeStats!
}

type PlayerAccount {
  level: Int!
  region: String!
  displayName: String!
  platform: String!
  stats: PlayerAccountStats!
  portrait: String!
}

type Player {
  name: String!
  accounts: [PlayerAccount!]!
  account(region: String!, platform: String!): PlayerAccount
}

type Query {
  player(name: String!): Player,
  teams(after: String, first: Int!): LeagueTeamConnection @cost(compelexity: 1)
  ranks: [LeagueRank]
  stages(after: String, first: Int!): LeagueStageConnection @cost(complexity: 1)
}
`;

export function loadSchemaFile() {
  return readFileSync(schemaFile).toString();
}

export function loadSchema() {
  return makeExecutableSchema({
    typeDefs: loadSchemaFile(),
    resolvers,
    logger: console
  });
}

// Builds a training set by combining multiple stats payloads for the given accounts
async function loadTrainingSetData(accounts) {
  const mergedSet = await Promise.reduce(
    accounts,
    async (data, account) => {
      return merge(
        data,
        (await getPlayerStats(account.name, account.region, account.platform))
          .stats
      );
    },
    {}
  );

  return { ...mergedSet.quickplay, ...mergedSet.competitive };
}

// Returns the GraphQL scalar type (from a limited set) from the given value,
// by inspecting its type
function scalarTypeFromValue(value) {
  if (typeof value === "number") {
    if (value % 1 === 0) {
      return "Int";
    }

    return "Float";
  } else if (typeof value === "string") {
    return "String";
  } else {
    throw new Error(`Could not infer scalar type from '${value}'`);
  }
}

export async function generateSchema(trainingAccountsSet) {
  const trainingSet = await loadTrainingSetData(trainingAccountsSet);

  // Iterate through each hero:
  const heroes = Object.keys(trainingSet).map(name => {
    console.log(name);
    const heroTypeName = title(`${name}Stats`);
    const heroStats = trainingSet[name];

    // Iterate through each stats group for this hero:
    console.log(heroStats);
    const groups = Object.keys(heroStats).map(group => {
      if (group === "name" || group === "rawName") {
        return { type: "" };
      }

      const groupTypeName = `${title(name)}${title(group)}Stats`;
      const groupStats = heroStats[group];

      // Finally, walk through each stat name/value to infer its type:
      console.log(Object.keys(heroStats), group);
      console.log(Object.keys(groupStats));
      const statTypes = Object.keys(groupStats).map(stat => {
        const value = groupStats[stat];

        return `${stat}: ${scalarTypeFromValue(value)}!`;
      });

      return {
        groupTypeName,
        groupName: group,
        type: `type ${groupTypeName} { ${statTypes.join("\n    ")} }`
      };
    });

    return {
      heroTypeName,
      heroName: name,
      type: `
        # == ${name} types ==

        ${groups.map(group => group.type).join("\n")}
        type ${heroTypeName} {
          ${groups
            .map(
              group =>
                group.groupName && `${group.groupName}: ${group.groupTypeName}`
            )
            .join("\n  ")}
        }
      `
    };
  });

  return `
    ${baseSchema}

    # == The following types are auto-generated ==

    union HeroStats = ${heroes.map(hero => hero.heroTypeName).join(" | ")}
    type GamemodeStats {
      ${heroes.map(hero => `${hero.heroName}: ${hero.heroTypeName}`).join("\n")}
    }

    ${heroes.map(hero => hero.type).join("\n")}
  `;
}
